第四章 面向对象2
继承机制：可以让程序设计变得轻松简便
**继承的目的：在程序设计或者人家开发中，因为已经有很多年的市场了。在开发一个程序时，往往相关的工作，或者有关联的工作之前已经进行过。比如：学校中需要开发一个成绩管理系统，那么很可能教职工系统和学籍注册系统，早就开发过了。如果恰好是一个软件公司在继续开发，则教师和学生的基本信息管理部分，可以继续使用。怎么样继续使用？
面向对象的继承机制，可以良好的解决这样的重复利用的需求。继承简单来讲就是，先拿来，再修补的过程。
****学程序设计，要先理解程序的思路，推理程序的逻辑过程，练习代码编写，积累编程的经验，当经验积累到一定程度，对程序有了一定深度的认识，才能用程序的思维去分析实际问题。
面向对象三大特征，封装是为了给继承做准备，当子类继承父类之后，如果对继承到的某些功能（方法）不满意，则可以去重写那些方法，子类对父类有了方法重写后，才能有多态。

Java继承机制的特点：
（1）类extends关键字后边只能跟一个类名，称作一个类，只能有一个直接的父类。
（2）类的继承可以多层单继承，比如：B继承了A，C继承了B，D还可以继续继承C。
（3）多个类，可以继承同一个类，比如：B，C，D三个类都可以继承A类。

子类重写父类的方法
当子类继承父类之后，对父类中已经定义的方法，设计的功能不满意，但是想继续用该功能的名字，此时可以对父类中的方法重写。
方法重写的特点：
（1）子类对父类的方法重写，没有继承没有重写
（2）方法名称、参数列表一样，重写的方法返回类型的可以和被重写方法返回类型一样，或者是被重写方法返回类型的子类。
目前将返回类型重写时写成一样。
（3）重写的方法权限不能比被重写方法的权限低。

super关键字
当子类中的成员变量和父类中成员变量同名时，或者子类中对父类某些方法重写后，在子类对象中访问同名变量或者重写的方法时，就会对父类中同名变量或者被重写的方法隐藏。
怎么样在子类中再讲那些被隐藏的资源，进行访问？

创建一个子类对象时，必然要先创建一个他的直接父类的对象。
this和super：Java中每个对象都有两个隐含的引用变量，this指向自身，super指向它所包含父类对象。
在子类中存在和父类同名变量时，this.变量名，访问子类中的变量，super.变量名，访问父类中同名变量。当子类中对父类方法重写后，this.方法调用，访问子类对象自己的方法。super.方法调用，访问父类中被重写的方法。
***对于子类中重写父类的方法，子类对象中保存着重写方法的入口地址，子类对象包含的父类对象中，保存着被重写的方法入口地址。

super关键字还可以调用父类的构造器，使用super访问父类构造器的原因是，父类的构造器不能被子类继承。

this和super的对象引用示意图
this和super，Java中每个对象隐含保存两个引用变量，this指向自己，super指向自身包含的父类对象（如果没有显示的继承，则包含Object对象），JRE环境执行对象时，一个具体时刻只能使用一个，则this和super就不会出现冲突。
this和super不能出现在static区域中。调用构造器时，二者不能同时出现，因为访问构造器时，这俩都要求必须是第一条语句。
final关键字的使用
final单词的意思是，最终的。在Java中该关键字可以修饰变量、方法、类。在程序设计中，代表不能改。
（1）final修饰变量
class FinalTest1 {
	//定义变量
	int m1;
	final int m2;
	//定义方法
	public static void fun1(){

	}
}

final修饰的量，是常量，只能定义时进行初始化，之后值不许修改。
（2）final修饰方法
final修饰的方法“不能修改”，对于方法而言，修改代表同样的方法名称、返回类型、参数列表，但是调用时功能改变。这样的情况发生在子类对父类的方法，重写之后。
当对父类的final方法，子类重写时，会出现下面错误。

（3）final修饰类
final代表着，不能修改。对于类而言，运行时的修改是什么含义？可以这么理解，就是在内存的代码区中重新加载一个对某个类的修改版代码。对类的修改就是“扩展”，用继承实现。所以final修饰的类不能被继承。
当对一个final class  派生子类是，会出现以下错误。

*** 遇见final关键字，就想到“三不原则”，final量不能改值，方法不能重写，类不能继承。

抽象类和接口
抽象类
所谓抽象，直观的意思就是“不正常”，有些特殊。
抽象类出现的原因是，类中某个功能不确定，不正常，在类中的代码表现为某个方法没有方法体，后面直接是;  语句结束。因此该类就没办法直接使用（不能实例化），所以类就要加个标记：abstract
**包含抽象方法的类，成为抽象类
对抽象类实例化会出现下面错误。

由于抽象类中某个功能不正常，不确定，所有实例化没有意义，不能创建对象。
？？抽象类怎么用？
抽象类实际上是，定义了一些规范，比如自行车，规定必须有刹车，但是刹车是V刹、碟刹、油刹，还是倒蹬闸，具体根据型号，厂家自行设计。
在Java中，抽象类就类似一些规范的定义类，具体使用时，需要对该规范定义类进行具体的扩展，然后才能使用。
当子类继承抽象类后，如果没有重写抽象方法，会出现下面错误。

两个选择，一 把子类也定义为abstract
二  把继承的抽象方法，重写为正常的。

接口：interface
如果一个类里面的所有方法都是抽象方法，类抽象到极端了。
称作抽象类不足以表示其特殊和抽象。就需要另叫名字：接口
关键字：interface
既然已经另起名字，表示其特殊性了，也就是所有方法肯定全部抽象

**接口中的方法，全部默认就是  public abstract
**接口中也可以设计"量"，默认就是 public static final

接口的用法
接口是用来定义一组标准，只规定功能，不规定具体实现。开发中作用是在团队中，起到定义标准、程序间的通信接口。
接口可以继承其他接口，而且可以多继承。
一个类可以实现多个接口，称作间接多继承。
一个类，可以继承一个类的同时，实现多个接口
比如：一个类：椅子，两个接口：能坐的工具、能躺的工具，可以设计一个沙发类，继承椅子，同时实现能坐的和能躺的两个接口。（完成作业，模拟过程）

多态
面向对象中的多态是指，同样的一个引用变量，在运行时可以指向多种对象，调用同名的方法，但是运行的功能截然不同。
比如：老板说：小刘，给你一辆车，你驾驶它去电子市场买笔记本，小刘很高兴。拿着钥匙去了。发现是一两自行车。小刘刚走，老板又叫：小李，给你一辆车，你去税务局，办事。小李看见的一辆电动摩托。
  *** 引用变量是“车”，运行时，这个变量可以指向任何一个符合定义的对象，比如自行车、摩托车、汽车，都可以。“车”这种对象，有一个方法“驾驶”，同样的引用变量“车”，真正见到时，使用驾驶功能时，发生状态完全不同，称作多态。
**多态的前提是：有子类父类的继承，有子类对父类方法的重写。

对象的类型转换
（1）对象上转型
将子类对象转换为父类类型，称作对象上转型。
应用中，一般是将变量声明为父类对象，运行时可以让它指向任意的子类对象，专门用对象上转型机制，如果子类和父类存在方法重写，则会发生多态。
多态的本质：程序运行时，父类对象的引用可以任意指向子类对象，并且遵循“是什么对象运行什么功能”的原则，就是多态。
（2）对象的下转型
将父类的对象，强制类型转换为子类对象。
对象的强制类型转换，必须注意"该对象能够被转换"，也就是真正是那种类型，可以进行转换。
将父类的对象，强制转换为子类对象，称作对象的下转型针对上转型而言，下转型不安全，上转型一般是安全。
就像：能说老虎是动物，反之不能说动物就是老虎。
下转型的应用前提：真正是一只老虎，但是带的帽子写的是动物此时可以把帽子换成老虎。
instanceof 运算符用于在运行时，判断某个对象是不是某个类型的实例，经常用在对象下转型前，先判断能不能转换。就像，要将一只动物，转换为老虎，那么就必须先判断，该动物是不是老虎。
对于对象而言，类型转换仅仅是改变其“名字”，对象的真正内存结构，不可能更改。
对象的上转型是自动的，但是对象的下转型需要强制进行。上转型是安全的，下转型不安全。
Object类
Object类中的方法，开发程序时如果需要使用，则都需要重写。

匿名类（匿名内部类）
匿名类又称匿名内部类，是一种特殊的内部类，没有类名，直接使用的是该类的对象，只使用一次。

模仿课堂抽象类飞行器Flyer类的匿名内部类调用，自己写一个接口形式的实现。

对于某些场合，比如一个射击类游戏，在场景中玩家控制的坦克要发射炮弹，炮弹再去试行攻击任务。
坦克类需要发射炮弹的方法，该方法需要什么参数？需要炮弹类的参数，炮弹种类众多，比如小的，连发的，打击面的，等等。炮弹类中主要的方法就是攻击。
对于需要访问外部类中的属性，而且一种子类的对象经常只用一次，写成匿名类比较方便。
匿名内部类经常用Java的swing事件机制里。

异常
   异常：意外情况，程序运行期间会遇到各种各样的状况，而且其中有很多是无法控制和预测的，比如程序运行环境引发的，如：一个网络通信聊天的程序，突然就网络中断了，或者断电了。等等意外情况。

程序产生异常之后，直接的结果就是程序崩溃了！这个是不可饶恕的，程序可以出错，可以不干活，但是不能不响应。就算出现了异常，也要做到及时通知用户。


上面程序，20行运行时会出，除0异常，然后程序直接就崩溃了，导致21、22行语句不会执行。如果真正开发中，21、22行是程序末尾关闭相关资源的语句，轻则其他用户无法使用，重则相关资源会出现数据丢失。
   称作，程序是不可控的。学习异常处理机制，不可能完全避免异常的出现，但是可以做到，出现异常之后，程序依然是受控制的。
  控制异常流程的try catch finally语句块

使用try-catch进行处理之后，程序正常结束。

用了异常处理机制后，程序变得可控。
try catch finally  三个语句块的控制作用及特点：
当无异常产生时，try块和finally块会执行完，而catch块语句块不执行。
当有异常产生时，try块中产生异常的语句之后部分，不再执行，直接跳到catch部分执行，finally块执行完。
***finally语句块不论有没有异常，都会执行完。因此适合用来进行程序的清理工作，比如释放相关资源。

异常机制中，重点学习五个关键字：try，catch，finally，throw，throws
throw：在某些可能产生异常的情况下，当有异常时，真正抛出一个具体的异常对象。
throws：当有些方法可能会出现异常时，在该方法的圆括号和花括号中间，使用throws关键字，声明抛出某种异常类型。

包 package
想象一个场景，一个公司的某个开发小组，共8人。需要开发一个学籍管理系统。假设学生基本信息模块一个人，学生选课信息一个人，等。任务分配。项目规定，每完成一部分功能就进行集成测试，专门有一台集成测试的机器，classpath设置是
D:\SutdentSysclass，开发人员多少会一些英语基础。上面提到的两个开发人员，都想到了用单词来设计类名，不约而同的使用了Student作为类名。
   由于编译之后的两个Student.class文件名称完全一样，测试时需要将类的字节码文件复制到目标机器中的classpath目录中，则会发生文件覆盖的问题。
   解决这种问题，需要定义不同的类名(*.class)，但是类名定义需要见名之意。可以借鉴一种平时使用地名的用法：比如解放路这个道路的名称，很多城市都有。背景.解放路 ；西安.解放路，将这种加了名称限定的用法，称作全名。
  在Java中，为了解决类的命名冲突（同名的.calss会发生覆盖问题），使用了包机制。
  **windows中，对于同名的文件如何存储？用不同的目录机构存储。包就是这样的思想。同名的.class文件，可以存储在不同的文件夹下。其中不同的文件夹路径就是用package语句指定的。
**思考：Java怎么解决类名相同时的冲突问题？
  1 在classpath中用不同的文件夹路径，存储可能同名的 .class文件。
  2 运行时需要将存储的文件夹路径，和加载类时的类名关联。称作类的全名，就是报名.类名，其中包名对应着存储时的文件夹路径。
包的关键字：package，其后的语句可以指定多层文件夹路径。
  课堂示例在：D:\javawork\class3\ch4\pak
  当package中定义的报名结构层数太多时，手工创建文件夹的方式太麻烦了。可以使用编译参数自动生成报名结构。
  javac –d . ***.java   可以自动创建带完整包路径的文件夹结构，并且将编译好的.class放入。
缺省包：之前学习中，一直没有使用package语句等一包，但是这样的类还是有包，称作缺省包。

import语句
当两个（或多个）类互相需要访问时，各自都定义不同的package，则默认互相是看不到的。有两种方式互相访问：
1 需要访问的带包名的类，权限必须是public
  一个类需要被其他包中的类访问时，则权限必须是public；同一个包中（package没有或者一样的），缺省权限的class就可以直接互相访问。
2 使用全名
包名.类名 构造器也必须使用全名。
3 导入需要访问的包
import 语句。

学完包机制后，换Java的编写工具Eclipse
下载eclipse for java版
在磁盘某个分区解压缩
启动之前先创建eclipse的源码工作目录
使用eclipse之前，先配置JAVA_HOME环境变量，值是本机Java安装的主目录（bin文件夹的上一层）。

启动eclipse时选择自己创建的工作目录。
第一次打开的界面

点击右上角 workbench，工作台按钮。
打开主界面后，首先配置JDK

window菜单最后一个命令，代开对话框

在左侧选择图中所示的选项，在右侧单击add命令

选择标准VM
选择本机上安装的Java的主目录(bin的上一层)选中。
最后单击完成按钮。

如图中所示，新建Java的项目

输入项目名称，单击完成。
在左侧src文件夹上，右击，选中新建package，输入包名。

在新建的报名上，右击，新建class，输入名称，继续写代码，添加main方法，就可以运行测试了。

作业：用eclipse，练习课本上的包机制，中的例子。

4.7 访问控制
Java中的访问控制就是指类、变量、方法等，程序中资源的访问权限。访问控制，是站在软件系统的角度而言。



修改代码的字体，如图中所示位置。右侧窗口中，选择Basic-text font

在eclipse中，建议一个类，就是一个.java文件。

（1）类的访问权限有两种：缺省的(也称作包权限)、public
class关键字之前如果没有定义权限，就称作”缺省的”也叫包权限，因为只能被同一个包中的其他类访问。
class前面加上public权限，才能被其他包中类访问，而且访问时需要导入或者用类的全名。
（2）类中属性的访问权限
属性的访问权限有四种：private、缺省的、protected、public。
这四种权限的访问，要分四种使用的情况进行分析
a. 同一个类中
b. 同一个包中
c. 不同包但是属于继承关系
d. 不同包、不是继承关系
***注，课后自行测试
（3）类中方法的权限访问权限有四种：private、缺省的、protected、public。
这四种权限的访问，要分四种使用的情况进行分析
a. 同一个类中
四种权限全都可以访问。
b. 同一个包中
   同一个包中，可以访问：缺省的、protected、public
c. 不同包但是属于继承关系
   可以访问：protected、public

***注：同包比不同包但是继承关系，可访问权限要多，印证了：远亲不如近邻。
d. 不同包、不是继承关系
   只能访问public
** 注意，Java的权限控制，是发生在编译时，不能完全依赖于这种权限控制，在运行时使用java的反射机制，完全可以绕过这些限制。

第六章 Java API
  API：应用程序编程接口，就是Java提供的可以直接使用的类以及方法、属性。
6.1 Java的字符串处理类
   字符串是程序员工作中，打交道最多的一种数据。
String、StringBuffer、StringBuilder
   这里主要学习前两个。
  String类的用法
  String类是一个final类，表示不可变的字符串对象

给定一个比较长的字符串，统计单词数量，再给一个子串，统计该子串出现的次数。